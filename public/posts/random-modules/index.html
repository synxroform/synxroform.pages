<html lang=ru>
    <head>
        <title> Random Modules </title>
        <link rel="stylesheet" href="/css/page_style.css" />
        <link rel="stylesheet" href="/css/article_style.css" />
        <link rel="stylesheet" href="/css/picture_style.css" />
        <link rel="stylesheet" href="/css/syntax.css" />
        <link rel="stylesheet" href="/css/image_viewer.css" />
    </head>

    <body>
        <div class="head_white_background"></div>
        <div class="head_background"></div>
        <div class="button_panel">
            <a href="/index.html">
                <img src="/images/home-icon-silhouette.svg" height=35px style="margin-right: 20px;"/>
            </a>
            <a href="http://github.com/synxroform/">
                <img src="/images/GitHub_alt-512.png" height=40px/>
            </a>

        </div>

            
            <a href="/posts/apollonian-gasket/">
                <svg class="arrow_back" viewBox="0 0 477.175 477.175">
                    <linearGradient id="lin_grad">
                        <stop offset="0%" stop-color="#fff"></stop>
                        <stop offset="100%" stop-color="#fff0"></stop>
                    </linearGradient>
                    <g>
                        <path d="M145.188,238.575l215.5-215.5c5.3-5.3,5.3-13.8,0-19.1s-13.8-5.3-19.1,0l-225.1,225.1c-5.3,5.3-5.3,13.8,0,19.1l225.1,225c2.6,2.6,6.1,4,9.5,4s6.9-1.3,9.5-4c5.3-5.3,5.3-13.8,0-19.1L145.188,238.575z" fill="url(#lin_grad)"></path>
                    </g>
                </svg>
            </a>
            
            
            
            <a href="/posts/herzog-continued/">
                <svg class="arrow_next" viewBox="0 0 477.175 477.175">
                    <linearGradient id="lin_grad2">
                        <stop offset="0%" stop-color="#fff0"></stop>
                        <stop offset="100%" stop-color="#fff"></stop>
                    </linearGradient>
                    <g>
                        <path d="M360.731,229.075l-225.1-225.1c-5.3-5.3-13.8-5.3-19.1,0s-5.3,13.8,0,19.1l215.5,215.5l-215.5,215.5 c-5.3,5.3-5.3,13.8,0,19.1c2.6,2.6,6.1,4,9.5,4c3.4,0,6.9-1.3,9.5-4l225.1-225.1C365.931,242.875,365.931,234.275,360.731,229.075z" fill="url(#lin_grad2)"></path>
                    </g>
                </svg>
            </a>
            

        <div class="page_container">
            <div class="page_head">
                <a class="page_button" href="/posts"> список статей </a>
                <span class="page_logo"> СИНХРОФОРМА </span>
                <span class="page_date">06.11.2019</span>
            </div>

            <div class="page_id_container">
              <span class="page_id"> A.06 </span>
            </div>
            <div class="big_arrow"></div>
            <article class="page_text"><p>Вот уже несколько тысячелетий, создавая своё окружение, человечество, в той или иной степени,
неизменно следует принципам модульного проектирования. И хотя, современные технологии, позволяют
создавать свободные формы, большинство дизайнеров, исходя из экономических соображений, вынуждены
применять в своих разработках модульное деление. Но простое многократное копирование в редких
случаях приводит к хорошему внешнему виду. О важности вариаций прекрасно знают дизайнеры, которым
приходилось выбирать плиточный материал для больших поверхностей. При неправильно составленном
модуле, в глазах начинает &ldquo;рябить&rdquo;, и длительное прибывание в таком помещении у большинства
вызывает чувство дискомфорта. Массивные скопления предметов, встречающиеся в природе, как правило,
составлены случайным образом. Отдельные элементы варьируются по различным параметрам: положению,
оттенку, размеру. Так, например, плитка из натурального мрамора имеет неповторимый рисунок и смотрится
гораздо лучше её имитации с повторяющимся шаблоном.</p>

<p>В период после Второй Мировой, на волне всеобщей рационализации, принцип модульного проектирования стал
оформляться как методология. Применение однотипных компонентов, требующих небольшого числа
производственных операций, способствовало оптимизации ресурсов. В шестидесятые годы, когда благосостояние
населения стало расти, использование модулей, доведённое до психоделического максимализма, превратилось
в творческий протест.</p>

<div class="picture">
    <img src="/posts/images/random-modules/sixties-modular.png">
</div>

<p>Мы, в свою очередь, рассмотрим принципы построения одного орнамента, появившегося как раз в те годы.
Изначально, в алгоритмическом искусстве применялись ручные методы расчета. С распространением
компьютеров многие художники перешли к их использованию. Для создания такого простого орнамента,
как рассматриваемый нами, вовсе не обязательно вычислять его на компьютере, однако, формализация
метода позволяет расширить область его применения. В совокупности с программируемыми станками,
алгоритм позволит создавать уникальные отпечатки орнамента, что является недостижимым при ручном
составлении рисунка.</p>

<p><img src="/posts/images/random-modules/main_views.svg" width=100%></p>

<p>Несмотря на то, что представленные орнаменты имеют похожие модули, принципы их построения различны,
впрочем как и характеристики. Орнамент расположенный справа можно использовать при проектировании
лабиринта: открытость диагонали гарантированна, все области изолированны и не имеют внутренностей.
Если орнамент слева использовать для создания прорезей, то внутренние окружности выпадут вместе с
охватывающей их областью.</p>

<p>Итак, алгоритм построения &ldquo;левого&rdquo; орнамента заключается в случайном копировании пары модулей.</p>

<p><img src="/posts/images/random-modules/random-blob-simple.svg" width=100%></p>

<p>Для &ldquo;правого&rdquo; орнамента мы применим алгоритм, который я назвал HYDRA. Впрочем, может сгодиться
любое существо, выпускающее свои щупальцы в разные стороны. Итак, взглянем на модули, которые нам
необходимо будет скопировать в некоторую сетку.</p>

<p><img src="/posts/images/random-modules/random-blob-variants.svg" width=100%></p>

<p>В нескольких словах, метод можно описать следующим образом: выбираем из общей сетки некоторую
ячейку, отмечаем её как тело гидры, если есть возможность расти, захватываем прилегающую к телу
свободную ячейку, добавляем её к гидре, ячейки у которых захвачены все направления убираем из тела.
В качестве критерия возможности роста, я использую общее количество захваченных ячеек.</p>

<p><img src="/posts/images/random-modules/random-blob-path.svg" width=100%></p>

<p>Параллельно с ростом, необходимо штамповать наши модули в сетку удвоенной размерности. Алгоритм
штампования довольно хитрый и требует детального рассмотрения.</p>

<p><img src="/posts/images/random-modules/random-blob-subgrid.svg" width=100%></p>

<p>В нетронутом виде удвоенная сетка заполнена нулями. Перечисляя по модулю ячейки, мы воспроизводим
ещё не разросшееся состояние, в котором каждая клетка является маленькой гидрой. По мере разрастания,
переходы между клетками заполняются числами, кодирующими характер перехода. Двойка означает горизонтальный
переход, тройка - вертикальный. При наложении двойки и тройки по модулю четыре, возникает
горизонтально-вертикальный переход, который мы реализуем с помощью простой перекодировки базовой сетки.</p>

<p><img src="/posts/images/random-modules/random-blob-numbering.svg" width=100%></p>

<p>На изображении показаны методы перечисления сторон и ячеек, а также соответствие значений удвоенной
сетки общему расположению модулей. Стоит отметить, что Julia использует единичную индексацию, которая
иногда приводит к усложнению алгоритма. Поэтому рассмотрение нашего алгоритма мы начнем с вспомогательных
функций, упрощающих индексирование массивов.</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">compass</span> <span class="o">=</span> <span class="kt">CartesianIndex</span><span class="o">.</span><span class="p">(((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

<span class="k">function</span> <span class="n">scale_idx</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">idx</span> <span class="o">+</span> <span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="n">one</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">function</span> <span class="n">stencil</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">hv</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">di</span> <span class="kp">in</span> <span class="n">CartesianIndices</span><span class="p">((</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">di</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">di</span><span class="p">]</span> <span class="o">+</span> <span class="n">hv</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
    <span class="k">end</span>
<span class="k">end</span></code></pre></div>
<p>Переменная compass содержит массив, кодирующий четыре стороны ячейки в соответствии с приведённой
выше схемой. Тип CartesianIndex используется при программировании алгоритмов произвольной размерности.
Например, можно выполнять приращение индекса как idx + one(idx), а итерацию в многомерном массиве
осуществлять посредством одного цикла, что можно наблюдать в функции stencil.</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">for</span> <span class="n">idx</span> <span class="kp">in</span> <span class="n">CartesianIndices</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="c"># тело цикла</span>
<span class="k">end</span>

<span class="c"># вместо</span>

<span class="k">for</span> <span class="n">x</span> <span class="kp">in</span> <span class="n">axes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">x</span> <span class="kp">in</span> <span class="n">axes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c"># тело цикла</span>
    <span class="k">end</span>
<span class="k">end</span></code></pre></div>
<p>Функция scale_index, как раз и создана потому, что индексация основанная на единице не допускает
простого растяжения. Для перечисления каждого второго или каждого третьего, мы не можем использовать
N*2 или N*3, хотя, с точки зрения логики, наличие первого элемента во всех множествах, образованных
предикатом каждый N, тоже, довольно сомнительное явление, что присуще индексации основанной на нуле.
Также, scale_index можно записать в виде idx * n - one(idx) * (n-1). Выражение idx * n - n + one(idx)
не подойдёт, хотя и имеет меньшее количество операций, поскольку мы не можем складывать целые числа и индексы.</p>

<p>Функция stencil отпечатывает параметры шаблона в удвоенной сетке. CartesianIndices((0:n, 0:n)) генерирует
квадрат лежащий выше некоторого базового индекса. А теперь, наверное, самая мутная часть алгоритма.</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">function</span> <span class="n">hydra_grid</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">maxgen</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">sub_grid</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="kt">Int8</span><span class="p">,</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">width</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">top_grid</span> <span class="o">=</span> <span class="kt">Set</span><span class="p">(</span><span class="n">CartesianIndices</span><span class="p">((</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">)))</span>
    <span class="k">while</span> <span class="n">length</span><span class="p">(</span><span class="n">top_grid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">group</span> <span class="o">=</span> <span class="kt">Dict</span><span class="p">{</span><span class="kt">CartesianIndex</span><span class="p">,</span> <span class="kt">BitArray</span><span class="p">}()</span>
        <span class="n">group</span><span class="p">[</span><span class="n">pop!</span><span class="p">(</span><span class="n">top_grid</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">gen</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">length</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">indexa</span><span class="p">,</span> <span class="n">edgesa</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="n">side</span> <span class="o">=</span> <span class="n">first</span><span class="p">(</span><span class="n">rand</span><span class="p">(</span><span class="n">filter</span><span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">last</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">collect</span><span class="p">(</span><span class="n">enumerate</span><span class="p">(</span><span class="n">edgesa</span><span class="p">)))))</span>
            <span class="n">indexb</span> <span class="o">=</span> <span class="n">indexa</span> <span class="o">+</span> <span class="n">compass</span><span class="p">[</span><span class="n">side</span><span class="p">]</span>
            <span class="n">edgesa</span><span class="p">[</span><span class="n">side</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">all</span><span class="p">(</span><span class="n">edgesa</span><span class="p">)</span>
                <span class="n">pop!</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">indexa</span><span class="p">)</span>
            <span class="k">end</span>
            <span class="k">if</span> <span class="n">indexb</span> <span class="kp">in</span> <span class="n">top_grid</span>
                <span class="n">di</span> <span class="o">=</span> <span class="n">compass</span><span class="p">[</span><span class="n">side</span><span class="p">]</span>
                <span class="n">stencil</span><span class="p">(</span><span class="n">sub_grid</span><span class="p">,</span> <span class="n">scale_idx</span><span class="p">(</span><span class="n">indexa</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">di</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">side</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">group</span><span class="p">[</span><span class="n">indexb</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">delete!</span><span class="p">(</span><span class="n">top_grid</span><span class="p">,</span> <span class="n">indexb</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">gen</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxgen</span>
                    <span class="k">break</span>
                <span class="k">end</span>
            <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="k">return</span> <span class="n">sub_grid</span>
<span class="k">end</span></code></pre></div>
<p>Переменная sub_grid представляет нашу удвоенную, инициализированную нулями, сетку. Ячейки сетки top_grid, в
которой развивается гидра, помещены во множество, что позволяет легко убирать поглощённые элементы,
оставляя только свободные ячейки. Цикл while length(top_grid) &gt; 0 управляет почкованием гидры, пока у
неё есть свободное пространство. Словарь group содержит тело, точнее индексированные клетки, содержащие
информацию о возможности роста. Разрастание нашего зверя происходит в while length(group) &gt; 0, что означает
что у гидры есть свободная поверхность и максимальное количество генераций не достигнуто. Выбирая случайно
&ldquo;гидрины&rdquo; клетки (rand(group)), мы находим свободные стороны (filter). Если свободных направлений не
осталось, выводим клетку из активного состояния (pop!(group, indexa)). В случае, если желаемая клетка
не занята собой или другой гидрой, печатаем штамп и забираем её в тело (delete!(top_grid, indexb)).
Если гидра исчерпала возможности для роста - начинаем выращивать другую.</p>

<p>Пока что, мы только построили сетку управляющую нашей геометрией. Теперь нам нужно построить саму
геометрию.</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">using</span> <span class="n">ShapeFactory</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">dispatch</span><span class="p">(</span><span class="s">&#34;CATIA.Application&#34;</span><span class="p">)</span>
<span class="n">prt</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">ActiveDocument</span><span class="o">.</span><span class="n">Part</span>

<span class="n">gst</span> <span class="o">=</span> <span class="n">prt</span><span class="o">.</span><span class="n">HybridBodies</span><span class="o">.</span><span class="n">Add</span><span class="p">()</span>
<span class="n">gst</span><span class="o">.</span><span class="n">Name</span> <span class="o">=</span> <span class="s">&#34;Output&#34;</span>

<span class="n">fac</span> <span class="o">=</span> <span class="n">prt</span><span class="o">.</span><span class="n">HybridShapeFactory</span>
<span class="n">xyp</span> <span class="o">=</span> <span class="n">prt</span><span class="o">.</span><span class="n">FindObjectByName</span><span class="p">(</span><span class="s">&#34;xy plane&#34;</span><span class="p">)</span>

<span class="n">pts</span> <span class="o">=</span> <span class="n">fac</span><span class="o">.</span><span class="n">AddNewPointCoord</span><span class="o">.</span><span class="p">((</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> 
<span class="n">ccs</span> <span class="o">=</span> <span class="n">fac</span><span class="o">.</span><span class="n">AddNewCircleCtrRadWithAngles</span><span class="o">.</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">xyp</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> 
                                        <span class="p">(</span><span class="mi">180</span><span class="p">,</span> <span class="mi">270</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">270</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">90</span><span class="p">))</span>

<span class="n">pts</span> <span class="o">=</span> <span class="n">fac</span><span class="o">.</span><span class="n">AddNewPointCoord</span><span class="o">.</span><span class="p">((</span><span class="mi">500</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">500</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">lns</span> <span class="o">=</span> <span class="n">fac</span><span class="o">.</span><span class="n">AddNewLinePtPt</span><span class="o">.</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">4</span><span class="p">])</span>

<span class="n">gst</span><span class="o">.</span><span class="n">AppendHybridShape</span><span class="o">.</span><span class="p">(</span><span class="n">ccs</span><span class="p">)</span>
<span class="n">gst</span><span class="o">.</span><span class="n">AppendHybridShape</span><span class="o">.</span><span class="p">(</span><span class="n">lns</span><span class="p">)</span></code></pre></div>
<p>Приведённая выше программа строит четыре арки и две прямые - это и есть наши модули. Геометрию нужно
добавить в параметрические множество, иначе репликатор поглотит её, и вместо шести элементов в дерево
попадёт несколько сотен, что значительно снизит производительность CATIA. Код репликации выглядит
следующим образом.</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">grid</span> <span class="o">=</span> <span class="n">hydra_grid</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

<span class="k">for</span> <span class="n">y</span> <span class="kp">in</span> <span class="mi">0</span><span class="o">:</span><span class="n">size</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">x</span> <span class="kp">in</span> <span class="mi">0</span><span class="o">:</span><span class="n">size</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">mx</span><span class="p">,</span> <span class="n">my</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="mi">1000</span>
        <span class="n">xv</span> <span class="o">=</span> <span class="n">fac</span><span class="o">.</span><span class="n">AddNewDirectionByCoord</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">xd</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">mx</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">my</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">st</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="n">tx</span> <span class="o">=</span> <span class="n">fac</span><span class="o">.</span><span class="n">AddNewTranslate</span><span class="p">(</span><span class="n">lns</span><span class="p">[</span><span class="n">st</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">xv</span><span class="p">,</span> <span class="n">xd</span><span class="p">)</span>
        <span class="k">else</span>
            <span class="n">tx</span> <span class="o">=</span> <span class="n">fac</span><span class="o">.</span><span class="n">AddNewTranslate</span><span class="p">(</span><span class="n">ccs</span><span class="p">[((</span><span class="n">x</span><span class="o">+</span><span class="n">st</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span> <span class="o">+</span> <span class="p">((</span><span class="n">y</span><span class="o">+</span><span class="n">st</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">xv</span><span class="p">,</span> <span class="n">xd</span><span class="p">)</span>
        <span class="k">end</span>
        <span class="n">tx</span><span class="o">.</span><span class="n">VectorType</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">gst</span><span class="o">.</span><span class="n">AppendHybridShape</span><span class="p">(</span><span class="n">tx</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="n">prt</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span></code></pre></div>
<p>Программируя для CATIA, я то и дело, натыкаюсь на того или иного &ldquo;динозавра&rdquo;. В этот раз таким
&ldquo;динозавром&rdquo; оказался AddNewTranslate, который, по непонятным причинам, использует метры в качестве
единиц измерения, а погрешности в миллиметровом диапазоне просто зашкаливают. Отсюда все эти тысячи
в AddNewPointCoord. Вообще, Dassault Systemes следует решительно пересмотреть свой API, если они
хотят конкурировать с Grasshopper или Dynamo.</p>

<p>А теперь, давайте полюбуемся на орнамент шестидесятых в стиле двухтысячных.</p>

<div class="picture">
    <img src="/posts/images/random-modules/final-image-four.png">
</div>
<div class="picture">
    <img src="/posts/images/random-modules/final-image-one.png">
</div>
<div class="picture">
    <img src="/posts/images/random-modules/final-image-two.png">
</div>
<div class="picture">
    <img src="/posts/images/random-modules/final-image-three.png">
</div>
</article> 
        </div>
        <div class="footnote">
            <p>
                <span> synxroform :__zaika_denis / A.06 / 06.11.2019</span>
            </p>
        </div>
        
    </body>
</html>