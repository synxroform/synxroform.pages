
<!DOCTYPE html>



<html lang="en"> 
<head>

	        
			<script async src="https://www.googletagmanager.com/gtag/js?id=UA-159137770-1"></script>
			<script>
				window.dataLayer = window.dataLayer || [];
				function gtag(){dataLayer.push(arguments);}
				gtag('js', new Date());
	
				gtag('config', 'UA-159137770-1');
			</script>


	
	<meta charset="utf-8">
	<title>synxroform</title>
	<meta name="description" content=".">
	<meta name="author" content="zaika denis">
	
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	
	<link rel="stylesheet" type="text/css" href="/css/syntax.css">
	<link rel="stylesheet" type="text/css" href="/css/style.css">

	<link href="https://fonts.googleapis.com/css?family=Exo+2:300,400|Fira+Code|Roboto+Slab:400,300&display=swap" rel="stylesheet">

	
	<link rel="shortcut icon" href="/images/favicon.ico">
	<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">

</head>

<body>


	
	<div class="simple-menu">
		<a class="button" href="/index.html#post-table">INDEX</a>
		<a class="button" href="/about.html#mail">ABOUT</a>
	</div>	
	<div class="synxroform-logo">
				<img src="/images/synxroform_logo.svg" alt="" />
	</div>
	
		<div class="article-container">
					<div class="article">
						<h4 id="post-head">A.06 // Random Hydra modules</h4>
						<p>Вот уже несколько тысячелетий, создавая своё окружение, человечество, в той или иной степени,
неизменно следует принципам модульного проектирования. И хотя, современные технологии, позволяют
создавать свободные формы, большинство дизайнеров, исходя из экономических соображений, вынуждены
применять в своих разработках модульное деление. Но простое многократное копирование в редких
случаях приводит к хорошему внешнему виду. О важности вариаций прекрасно знают дизайнеры, которым
приходилось выбирать плиточный материал для больших поверхностей. При неправильно составленном
модуле, в глазах начинает &ldquo;рябить&rdquo;, и длительное прибывание в таком помещении у большинства
вызывает чувство дискомфорта. Массивные скопления предметов, встречающиеся в природе, как правило,
составлены случайным образом. Отдельные элементы варьируются по различным параметрам: положению,
оттенку, размеру. Так, например, плитка из натурального мрамора имеет неповторимый рисунок и смотрится
гораздо лучше её имитации с повторяющимся шаблоном.</p>

<p>В период после Второй Мировой, на волне всеобщей рационализации, принцип модульного проектирования стал
оформляться как методология. Применение однотипных компонентов, требующих небольшого числа
производственных операций, способствовало оптимизации ресурсов. В шестидесятые годы, когда благосостояние
населения стало расти, использование модулей, доведённое до психоделического максимализма, превратилось
в творческий протест.</p>

<p><img src="sixties-modular.jpg" alt="" /></p>

<p>Мы, в свою очередь, рассмотрим принципы построения одного орнамента, появившегося как раз в те годы.
Изначально, в алгоритмическом искусстве применялись ручные методы расчета. С распространением
компьютеров многие художники перешли к их использованию. Для создания такого простого орнамента,
как рассматриваемый нами, вовсе не обязательно вычислять его на компьютере, однако, формализация
метода позволяет расширить область его применения. В совокупности с программируемыми станками,
алгоритм позволит создавать уникальные отпечатки орнамента, что является недостижимым при ручном
составлении рисунка.</p>

<p><img src="main_views.svg" alt="" /></p>

<p>Несмотря на то, что представленные орнаменты имеют похожие модули, принципы их построения различны,
впрочем как и характеристики. Орнамент расположенный справа можно использовать при проектировании
лабиринта: открытость диагонали гарантированна, все области изолированны и не имеют внутренностей.
Если орнамент слева использовать для создания прорезей, то внутренние окружности выпадут вместе с
охватывающей их областью.</p>

<p>Итак, алгоритм построения &ldquo;левого&rdquo; орнамента заключается в случайном копировании пары модулей.</p>

<p><img src="random-blob-simple.svg" alt="" /></p>

<p>Для &ldquo;правого&rdquo; орнамента мы применим алгоритм, который я назвал HYDRA. Впрочем, может сгодиться
любое существо, выпускающее свои щупальцы в разные стороны. Итак, взглянем на модули, которые нам
необходимо будет скопировать в некоторую сетку.</p>

<p><img src="random-blob-variants.svg" alt="" /></p>

<p>В нескольких словах, метод можно описать следующим образом: выбираем из общей сетки некоторую
ячейку, отмечаем её как тело гидры, если есть возможность расти, захватываем прилегающую к телу
свободную ячейку, добавляем её к гидре, ячейки у которых захвачены все направления убираем из тела.
В качестве критерия возможности роста, я использую общее количество захваченных ячеек.</p>

<p><img src="random-blob-path.svg" alt="" /></p>

<p>Параллельно с ростом, необходимо штамповать наши модули в сетку удвоенной размерности. Алгоритм
штампования довольно хитрый и требует детального рассмотрения.</p>

<p><img src="random-blob-subgrid.svg" alt="" /></p>

<p>В нетронутом виде удвоенная сетка заполнена нулями. Перечисляя по модулю ячейки, мы воспроизводим
ещё не разросшееся состояние, в котором каждая клетка является маленькой гидрой. По мере разрастания,
переходы между клетками заполняются числами, кодирующими характер перехода. Двойка означает горизонтальный
переход, тройка - вертикальный. При наложении двойки и тройки по модулю четыре, возникает
горизонтально-вертикальный переход, который мы реализуем с помощью простой перекодировки базовой сетки.</p>

<p><img src="random-blob-numbering.svg" alt="" /></p>

<p>На изображении показаны методы перечисления сторон и ячеек, а также соответствие значений удвоенной
сетки общему расположению модулей. Стоит отметить, что Julia использует единичную индексацию, которая
иногда приводит к усложнению алгоритма. Поэтому рассмотрение нашего алгоритма мы начнем с вспомогательных
функций, упрощающих индексирование массивов.</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">compass</span> <span class="o">=</span> <span class="kt">CartesianIndex</span><span class="o">.</span><span class="p">(((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

<span class="k">function</span> <span class="n">scale_idx</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">idx</span> <span class="o">+</span> <span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="n">one</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">function</span> <span class="n">stencil</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">hv</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">di</span> <span class="kp">in</span> <span class="n">CartesianIndices</span><span class="p">((</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">di</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">di</span><span class="p">]</span> <span class="o">+</span> <span class="n">hv</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
    <span class="k">end</span>
<span class="k">end</span></code></pre></div>
<p>Переменная compass содержит массив, кодирующий четыре стороны ячейки в соответствии с приведённой
выше схемой. Тип CartesianIndex используется при программировании алгоритмов произвольной размерности.
Например, можно выполнять приращение индекса как idx + one(idx), а итерацию в многомерном массиве
осуществлять посредством одного цикла, что можно наблюдать в функции stencil.</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">for</span> <span class="n">idx</span> <span class="kp">in</span> <span class="n">CartesianIndices</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="c"># тело цикла</span>
<span class="k">end</span>

<span class="c"># вместо</span>

<span class="k">for</span> <span class="n">x</span> <span class="kp">in</span> <span class="n">axes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">x</span> <span class="kp">in</span> <span class="n">axes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c"># тело цикла</span>
    <span class="k">end</span>
<span class="k">end</span></code></pre></div>
<p>Функция scale_index, как раз и создана потому, что индексация основанная на единице не допускает
простого растяжения. Для перечисления каждого второго или каждого третьего, мы не можем использовать
N*2 или N*3, хотя, с точки зрения логики, наличие первого элемента во всех множествах, образованных
предикатом каждый N, тоже, довольно сомнительное явление, что присуще индексации основанной на нуле.
Также, scale_index можно записать в виде idx * n - one(idx) * (n-1). Выражение idx * n - n + one(idx)
не подойдёт, хотя и имеет меньшее количество операций, поскольку мы не можем складывать целые числа и индексы.</p>

<p>Функция stencil отпечатывает параметры шаблона в удвоенной сетке. CartesianIndices((0:n, 0:n)) генерирует
квадрат лежащий выше некоторого базового индекса. А теперь, наверное, самая мутная часть алгоритма.</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">function</span> <span class="n">hydra_grid</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">maxgen</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">sub_grid</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="kt">Int8</span><span class="p">,</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">width</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">top_grid</span> <span class="o">=</span> <span class="kt">Set</span><span class="p">(</span><span class="n">CartesianIndices</span><span class="p">((</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">)))</span>
    <span class="k">while</span> <span class="n">length</span><span class="p">(</span><span class="n">top_grid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">group</span> <span class="o">=</span> <span class="kt">Dict</span><span class="p">{</span><span class="kt">CartesianIndex</span><span class="p">,</span> <span class="kt">BitArray</span><span class="p">}()</span>
        <span class="n">group</span><span class="p">[</span><span class="n">pop!</span><span class="p">(</span><span class="n">top_grid</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">gen</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">length</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">indexa</span><span class="p">,</span> <span class="n">edgesa</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="n">side</span> <span class="o">=</span> <span class="n">first</span><span class="p">(</span><span class="n">rand</span><span class="p">(</span><span class="n">filter</span><span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">last</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">collect</span><span class="p">(</span><span class="n">enumerate</span><span class="p">(</span><span class="n">edgesa</span><span class="p">)))))</span>
            <span class="n">indexb</span> <span class="o">=</span> <span class="n">indexa</span> <span class="o">+</span> <span class="n">compass</span><span class="p">[</span><span class="n">side</span><span class="p">]</span>
            <span class="n">edgesa</span><span class="p">[</span><span class="n">side</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">all</span><span class="p">(</span><span class="n">edgesa</span><span class="p">)</span>
                <span class="n">pop!</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">indexa</span><span class="p">)</span>
            <span class="k">end</span>
            <span class="k">if</span> <span class="n">indexb</span> <span class="kp">in</span> <span class="n">top_grid</span>
                <span class="n">di</span> <span class="o">=</span> <span class="n">compass</span><span class="p">[</span><span class="n">side</span><span class="p">]</span>
                <span class="n">stencil</span><span class="p">(</span><span class="n">sub_grid</span><span class="p">,</span> <span class="n">scale_idx</span><span class="p">(</span><span class="n">indexa</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">di</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">side</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">group</span><span class="p">[</span><span class="n">indexb</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">delete!</span><span class="p">(</span><span class="n">top_grid</span><span class="p">,</span> <span class="n">indexb</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">gen</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxgen</span>
                    <span class="k">break</span>
                <span class="k">end</span>
            <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="k">return</span> <span class="n">sub_grid</span>
<span class="k">end</span></code></pre></div>
<p>Переменная sub_grid представляет нашу удвоенную, инициализированную нулями, сетку. Ячейки сетки top_grid, в
которой развивается гидра, помещены во множество, что позволяет легко убирать поглощённые элементы,
оставляя только свободные ячейки. Цикл while length(top_grid) &gt; 0 управляет почкованием гидры, пока у
неё есть свободное пространство. Словарь group содержит тело, точнее индексированные клетки, содержащие
информацию о возможности роста. Разрастание нашего зверя происходит в while length(group) &gt; 0, что означает
что у гидры есть свободная поверхность и максимальное количество генераций не достигнуто. Выбирая случайно
&ldquo;гидрины&rdquo; клетки (rand(group)), мы находим свободные стороны (filter). Если свободных направлений не
осталось, выводим клетку из активного состояния (pop!(group, indexa)). В случае, если желаемая клетка
не занята собой или другой гидрой, печатаем штамп и забираем её в тело (delete!(top_grid, indexb)).
Если гидра исчерпала возможности для роста - начинаем выращивать другую.</p>

<p>Пока что, мы только построили сетку управляющую нашей геометрией. Теперь нам нужно построить саму
геометрию.</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">using</span> <span class="n">ShapeFactory</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">dispatch</span><span class="p">(</span><span class="s">&#34;CATIA.Application&#34;</span><span class="p">)</span>
<span class="n">prt</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">ActiveDocument</span><span class="o">.</span><span class="n">Part</span>

<span class="n">gst</span> <span class="o">=</span> <span class="n">prt</span><span class="o">.</span><span class="n">HybridBodies</span><span class="o">.</span><span class="n">Add</span><span class="p">()</span>
<span class="n">gst</span><span class="o">.</span><span class="n">Name</span> <span class="o">=</span> <span class="s">&#34;Output&#34;</span>

<span class="n">fac</span> <span class="o">=</span> <span class="n">prt</span><span class="o">.</span><span class="n">HybridShapeFactory</span>
<span class="n">xyp</span> <span class="o">=</span> <span class="n">prt</span><span class="o">.</span><span class="n">FindObjectByName</span><span class="p">(</span><span class="s">&#34;xy plane&#34;</span><span class="p">)</span>

<span class="n">pts</span> <span class="o">=</span> <span class="n">fac</span><span class="o">.</span><span class="n">AddNewPointCoord</span><span class="o">.</span><span class="p">((</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> 
<span class="n">ccs</span> <span class="o">=</span> <span class="n">fac</span><span class="o">.</span><span class="n">AddNewCircleCtrRadWithAngles</span><span class="o">.</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">xyp</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> 
                                        <span class="p">(</span><span class="mi">180</span><span class="p">,</span> <span class="mi">270</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">270</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">90</span><span class="p">))</span>

<span class="n">pts</span> <span class="o">=</span> <span class="n">fac</span><span class="o">.</span><span class="n">AddNewPointCoord</span><span class="o">.</span><span class="p">((</span><span class="mi">500</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">500</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">lns</span> <span class="o">=</span> <span class="n">fac</span><span class="o">.</span><span class="n">AddNewLinePtPt</span><span class="o">.</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">4</span><span class="p">])</span>

<span class="n">gst</span><span class="o">.</span><span class="n">AppendHybridShape</span><span class="o">.</span><span class="p">(</span><span class="n">ccs</span><span class="p">)</span>
<span class="n">gst</span><span class="o">.</span><span class="n">AppendHybridShape</span><span class="o">.</span><span class="p">(</span><span class="n">lns</span><span class="p">)</span></code></pre></div>
<p>Приведённая выше программа строит четыре арки и две прямые - это и есть наши модули. Геометрию нужно
добавить в параметрические множество, иначе репликатор поглотит её, и вместо шести элементов в дерево
попадёт несколько сотен, что значительно снизит производительность CATIA. Код репликации выглядит
следующим образом.</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">grid</span> <span class="o">=</span> <span class="n">hydra_grid</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

<span class="k">for</span> <span class="n">y</span> <span class="kp">in</span> <span class="mi">0</span><span class="o">:</span><span class="n">size</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">x</span> <span class="kp">in</span> <span class="mi">0</span><span class="o">:</span><span class="n">size</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">mx</span><span class="p">,</span> <span class="n">my</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="mi">1000</span>
        <span class="n">xv</span> <span class="o">=</span> <span class="n">fac</span><span class="o">.</span><span class="n">AddNewDirectionByCoord</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">xd</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">mx</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">my</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">st</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="n">tx</span> <span class="o">=</span> <span class="n">fac</span><span class="o">.</span><span class="n">AddNewTranslate</span><span class="p">(</span><span class="n">lns</span><span class="p">[</span><span class="n">st</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">xv</span><span class="p">,</span> <span class="n">xd</span><span class="p">)</span>
        <span class="k">else</span>
            <span class="n">tx</span> <span class="o">=</span> <span class="n">fac</span><span class="o">.</span><span class="n">AddNewTranslate</span><span class="p">(</span><span class="n">ccs</span><span class="p">[((</span><span class="n">x</span><span class="o">+</span><span class="n">st</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span> <span class="o">+</span> <span class="p">((</span><span class="n">y</span><span class="o">+</span><span class="n">st</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">xv</span><span class="p">,</span> <span class="n">xd</span><span class="p">)</span>
        <span class="k">end</span>
        <span class="n">tx</span><span class="o">.</span><span class="n">VectorType</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">gst</span><span class="o">.</span><span class="n">AppendHybridShape</span><span class="p">(</span><span class="n">tx</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="n">prt</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span></code></pre></div>
<p>Программируя для CATIA, я то и дело, натыкаюсь на того или иного &ldquo;динозавра&rdquo;. В этот раз таким
&ldquo;динозавром&rdquo; оказался AddNewTranslate, который, по непонятным причинам, использует метры в качестве
единиц измерения, а погрешности в миллиметровом диапазоне просто зашкаливают. Отсюда все эти тысячи
в AddNewPointCoord. Вообще, Dassault Systemes следует решительно пересмотреть свой API, если они
хотят конкурировать с Grasshopper или Dynamo.</p>

<p><img src="final-image-four.jpg" alt="" />
<img src="final-image-one.jpg" alt="" />
<img src="final-image-two.jpg" alt="" />
<img src="final-image-three.jpg" alt="" /></p>

					</div>

				<div class="clear"></div>
		</div>




	
	<section class="footer">
		<span>A.06 // Random Hydra modules // <span style="font-family: sans-serif; color: #aaa">by__zaika_denis</span> </h4>
	</section>
	<div class="simple-menu">
		<a class="button" href="/index.html" style="background: rgb(144, 200, 252);">INDEX</a>
		<a class="button" href="/about.html" style="background: #eee;">ABOUT</a>
	</div>





</body>
</html>